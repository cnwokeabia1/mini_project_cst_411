
# coding: utf-8

# ## Mini-Project 1 - Monte Carlo Simulation of Radioactive Decay

# #### A radioactive isotope is an atom that has excess nuclear energy, making it unstable. This excess energy causes the atom to breakdown in a process called radioactive decay. For more information see [this Wikipedia article](https://en.wikipedia.org/wiki/Radionuclide).
# 
# #### If we have a sample of radioactive isotopes, the "radioactive half-life" is the time it takes for half the atoms in the sample to decay. "Radioactive half-life" is often shortened to just "half-life". After two half-lives, there will be one fourth the original sample, after three half-lives one eigth the original sample, and so forth. For example: 
# ![alt text](http://hyperphysics.phy-astr.gsu.edu/hbase/Nuclear/imgnuc/hlcurv.gif)
# 
# ##### Image credit: http://hyperphysics.phy-astr.gsu.edu/hbase/Nuclear/halfli.html#c1
# 

# Different elements have different half-lives. For example, the half-life of uranium-238 is 4.5 billion years. The half-life of plutonium-239 is 24,100 years and the half-life of thallium-201 is 73.1 hours. Given a container of thallium-201, half of the atoms will decay in 73.1 hours. Given a same size container of uranium-238, it will take 4.5 billion years before half the atoms decay.
# 
# The half-life of an element doesn't change. However, which atoms in the container actually decay is a truly random process. For any given atom, there is a probability of decay. The probability of decay is given by a constant times the time step. For example, element X has a decay rate, alpha, of 0.01 s<sup>-1</sup>. The probability of a particular atom decaying in 1 second is: probability = 0.01 * 1 = 0.01
# 
# 1.) Write a Monte Carlo simulation to simulate the decay of 100 atoms of element X with a time step of 1 second. Run your simulation for 300 seconds. Graph the number of remaining atoms at each 1 second time step.
# 
# We can also solve the decay rate analytically. At each time step, the number of atoms remaining (not decayed), N, is given by: 
# N = (original number of atoms in sample)*e<sup>-y</sup> where y = alpha * number of elapsed seconds. For example, after 1 second: y = -0.01 * 1 = -0.01 and 
# N = 100 * e<sup>-0.01</sup>. 
# After 2 seconds, y = -0.01 * 2 = -0.02 and
# N = 100 * e<sup>-0.02</sup>, etc., etc.
# 
# Plot the analytical solution on top of the Monte Carlo solution. In other words, make a single panel plot with the two results plotted on top of each other. Not a multi-panel plot.

# In[25]:


import numpy as np
import matplotlib.pyplot as plt


# In[47]:


# code here
#simulation 100 atoms
fin = []
atoms = 100

#loop for 300 seconds
for i in range(300):
    for x in range(atoms):
        decay = np.random.random()
        #if the random number generated 
        if (decay <= 0.01):
            atoms = atoms - 1
    fin.append(atoms)
    #print("Timestep: ", i+1, " Number of atoms remaining: ", atoms,)

print ('Final number of atoms remaining:', fin[-1])


# In[3]:


#analytic calculation
final = []
atoms2 = 100

#looping, yay (for 300 seconds)
for i in range(300):
    N = (atoms2)*np.exp(0.01*-i)
    final.append(N)
    #print(N)
    
print('Final number of atoms remaining:', final[-1])


# In[82]:


#visualization
# inline plotting
get_ipython().run_line_magic('matplotlib', 'inline')

#actual plotting
plt.plot(fin)
plt.plot(final)
plt.title('Monte Carlo Simulation vs Analytical (100 trials)')
plt.xlabel('Time')
plt.ylabel('Number of Atoms')
#plt.ylim(40, 60)


# 2.) Does your Monte Carlo simulation agree with the analytical solution? What does the Monte Carlo simulation say is the half-life of element X? What does the analytical solution say is the half-life of element X?

# ## The simulation does seem to agree with the analytical solution. The half life is 52s for the Monte Carlo simulation, while for the analytical solution, the half-life is around 70s

# 3.) Let's try again, but this time with 5,000 atoms in our sample. Repeat question 1. with 5,000 atoms (same alpha, same time step, same probability, same 300 second simulation, just a larger sample of atoms)

# In[42]:


# code here
#simulation
fin_2 = []
atoms3 = 5000
dec = 0

#loop for 300 seconds
for i in range(300):
    for x in range(atoms3):
        decay = np.random.random()
        #if the random number generated 
        if (decay <= 0.01):
            atoms3 = atoms3 - 1
            dec = dec + 1
    fin_2.append(atoms3)
    #print("Timestep: ", i+1, " Number of atoms remaining: ", atoms,)


# In[45]:


#analytic calculation
final_2 = []
atoms4 = 5000

#looping, yay (for 300 seconds)
for i in range(300):
    L = (atoms4)*np.exp(0.01*-i)
    final_2.append(L)
    #print(N)
    
#print('Final number of atoms remaining:', final_2[-1])


# In[50]:


#actual plotting
plt.plot(fin_2)
plt.plot(final_2)
plt.title('Monte Carlo Simulation vs Analytical (5000 trials)')
plt.xlabel('Time')
plt.ylabel('Number of Atoms')


# 4.) How do the results compare with 5,000 atoms in our sample? Why do you think this is?

# ### The results for the simulation seems to be very similar to each other when compared to the 100 atom sample. This may be due to the fact that there are more iterations. With more iterations of the simulations, the closer the results will be to the theoretical result we calculated in Question 3.

# 5.) Modify your simulation to keep track of how many decays happen in every 10-second window. For each scenario (the 100 atom sample and the 5,000 atom sample) run the simulation 1000 times. Make a histogram for each scenario showing the distribution of decays per 10-second window.
# 
# Running the two simulation 1000 time each may take 2 to 3 minutes. It's recommended that you place the histogram code in a separate cell from the simulations. This way, you can update the histograms without having to re-run the simulations.
# 
# You may find it easier to write your simulation as a function and call it twice - once with 100 atoms and a second time with 5000 atoms

# In[95]:


# code here
#simulation 100 atoms
def aaaah():
    sim_ends = []
    atoms = 100
    dec = []
    dec10 = []

    #loop for 300 seconds
    for i in range(300):
        decaying = 0
        for x in range(atoms):
            decay = np.random.random()

            if (decay <= 0.01):
                atoms = atoms - 1
                decaying += 1
                dec.append(decaying)
        if len(dec) == 10:
            s = sum(dec)
            dec10.append(s)
            dec = [] 
    return dec10

the_end = []                    
for x in range(1000):
    dec10 = aaaah()
    the_end.extend(dec10)
    


# In[97]:


# code here
#simulation 5000 atoms

def leedle():
    sim_ending = []
    atoms2 = 5000
    dec = []
    dec10 = []

    #loop for 300 seconds
    for i in range(300):
        decaying2 = 0
        for x in range(atoms2):
            decay = np.random.random()

            if (decay <= 0.01):
                atoms2 = atoms2 - 1
                decaying2 += 1
        dec.append(decaying2)
        if len(dec) == 10:
            s = sum(dec)
            dec10.append(s)
            dec = []
    return dec10

derp = []
for x in range(1000):
    dec10 = leedle()
    derp.extend(dec10)


# In[96]:


# histograms here
plt.hist(the_end)
plt.title('Ten Second Decays: 100 Trials')
plt.xlabel('Number of Decays')
plt.ylabel('Frequency')


# In[98]:



plt.hist(derp)
plt.title('Ten Second Decays: 5000 Trials')
plt.xlabel('Number of Decays')
plt.ylabel('Frequency')


# ##### 6.) The probability of a certain number of atoms decaying in a time window can be solve analytically as: 
# 
# p = [ (alpha * n * T)<sup>n</sup> * e<sup>-alpha * n * T</sup> ] / n!
# 
# where T is the time window (10 seconds in our case), n is the number of atoms decaying, and alpha is our decay rate from earlier (0.01). What is the probability of 5 atoms decaying in 10 seconds?

# In[13]:


# code here
np.power((0.01*5*10),5) *np.exp(-0.01*5*10)/(5*4*3*2*1)


# 7.) How many times did 5 atoms actually decay in our simulations? Hint: if you have an list you can use the count() function to find number of occurances. For example, if we have a list named x and we'd like to find how many times 5 occurs, we can do: print(x.count(5))

# In[100]:


# code here
#have to change size of the bins
print('100 trials: ', the_end.count(5))
print('5000 trials: ', derp.count(5))


# 8.) Would you like to add anything to question 4?
# ### I don't think I have anything else to add.
